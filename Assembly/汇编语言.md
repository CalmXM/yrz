# 基础知识

==基于王爽的《汇编语言》==





## CPU对存储器的读写

- **存储单元的地址**      ==地址信息==

- **对器件的选择，读或写**     ==控制信息==
- **读或写的数据**    ==数据信息==





## 总线

### 地址总线

反映了CPU的寻址能力



### 数据总线

宽度决定了CPU与其他器件之间一次传递的数据量



### 控制总线

反映了CPU对其他器件的控制能力







## cpu对指令和数据的划分

在取指令阶段，取出的二进制数都是指令；在指令执行期间访存所取出的二进制数都是数据



***在8086cpu中，被cs:ip所指向的地址空间都是指令***





##16位结构的CPU

> 笼统地说，16位结构和16位机、字长为16位含义相同



一般都如下结构特性

- 运算器一次可处理16位数据
- 寄存器的最大宽度为16位
- 寄存器和运算器之间的通路为16位





##8086cpu给出物理结构的形式

> cpu访问内存单元时，都要给出物理地址用于定位。不同的cpu形成物理地址的形式不同



- 8086cpu有==20==位的地址总线，但是其寄存器本身只有16位，如果只是简单的发出一个物理地址，只能形成一个==16==位的物理地址，即寻址能力只有==64K==
- 虽然硬件不支持，但可以通过一些技巧巧妙地实现。8086采用==2==个寄存器相配合实现物理地址，这样寻址能力就达到了==1M==



8086采用==段地址×16+偏移地址==的形式形成物理地址

![image-20210718193539573](C:\Users\翟\AppData\Roaming\Typora\typora-user-images\image-20210718193539573.png)



---------------------



###**段地址×16[基础地址]+偏移地址的本质**

> 值得一提的是，X进制的数左移==1==位，相当于乘了一次X
>
> 对于二进制而言，左移2的N次方位，它所对应的十进制数就扩大2的N次方倍



对于超出5位的运算结果，逻辑上没有问题，所以系统并不会因为访问越界而出现异常，而是从0开始计算，也就是说实际上的物理地址是通过对1M求模得到的



![image-20210719145410643](C:\Users\翟\AppData\Roaming\Typora\typora-user-images\image-20210719145410643.png)

’







## 程序的执行过程

- 在内存中找到一段起始地址为==SA：0000==的空闲区域
- 在这段内存区域的前面==256B==建立==PSP（段前缀）==，DOS利用PSP来和程序通信
- 紧接PSP，即在257个字节的地方，将程序装入，程序的起始地址为==SA+10H:0000==
- 将这块内存的段地址存入ds中，设置cs：ip指向程序的入口



![image-20210815104509645](C:\Users\翟\AppData\Roaming\Typora\typora-user-images\image-20210815104509645.png)























# 寄存器

8086CPU一共有==14==个寄存器，且所有寄存器都是==16==位





## 通用寄存器



### 数据寄存器

四个数据寄存器==AX    BX    CX     DX==



> 8086CPU是世界上第一个16位的CPU，出于对8位CPU的兼容，这4个寄存器都可分成两个独立的8位寄存器，以AX为例，表示为AH，AL，即高位和低位





#### AX

accumulator       ==累加寄存器==

```
常用于计算
```



#### BX

base       ==基址寄存器==

```
常用于地址索引,默认基于DS段寄存器
```



#### CX

count      ==计数寄存器==

```
常用于计数
```





#### DX

data     ==数据寄存器==

```
常用于数据传递
```





### 指针寄存器

#### SP

Stack Pointer      ==堆栈寄存器==

```
和SS段寄存器搭配使用，用于指向栈顶
```





#### BP

Base Pointer     ==基指针寄存器==

```
BP和<bx si di>类似，默认基于SS段寄存器，主要适用于直接存取栈中的数据
```





### 变址寄存器

#### SI & DI

SI(Source Index):   ==源变址寄存器==    

DI(Destination Index):   ==目的变址寄存器==

```
用于存放基于DS段寄存器的偏移地址，与bx类似，但不能拆分成两个独立的8位寄存器，这也是它们与bx的主要区别
```

​    







## 段寄存器

8086cpu有4个段寄存器：==CS    DS    SS     ES==



### 段的概念

对内存“段”的划分，是以8086cpu的角度来看，以分段的方式管理内存



因为偏移地址为16位，所以一个段的大小最多为==64KB==；同时因为基础地址都是通过==“乘16”==得来的，

所以一个段的起始地址都是16的倍数



### CS

code segment      ==代码段寄存器==



#### CS & IP

CS和IP是8086cpu中两个最关键的寄存器，分别表式

- CS     代码段寄存器
- IP      指令寄存器

*在任意时刻，8086cpu将CS：IP指向的内容当作指令执行*



```Assembly
jmp "段地址:偏移地址"           //更改CS:IP
jmp "合法的寄存器"             //更改IP
```





#### 8086cpu工作过程简单描述

- 通过CS：IP取指令
- IP+指令长度，从而指向下一条指令
- 执行指令，并回到第一步







### DS

data segment      ==数据段寄存器==



==bx  si   di==都基于此段寄存器



### SS

stack segment    ==栈段寄存器==



==SP  BP==基于此段寄存器



### ES

estra segment    ==附加寄存器==





## 控制寄存器

### IP

Instruction Pointer   ==指令指针寄存器==





### FLAG

==标志寄存器==























# 灵活的内存地址定位方法



## and & or

- and     双方都为“真”（1）才为“真”（1）
- or        有一方为“真”（1）就可为“真”（1）



### 大小写字母的转换

```
通过观察大小写字母的ASCII码发现，每个大写字母的十进制形式比小写字母小了32；

即，每个字母的大小写二进制形式的区别在于第5位数是0或1

因此对于大小写字母的转换问题，即可简化为对数位的修改问题
```



- 大写—>小写

```
or 0010 0000
```



- 小写—>大写

```
and 1101 1111
```



```assembly
assume cs:codesg,ds:datasg

datasg segment
db 'HelloWorld'
db 'MBR'
datasg ends

codesg segment
start:mov ax,datasg
      mov ds,ax
      mov bx,0
      mov cx,10    

s:mov al,[bx]
and al,11011111B
    mov [bx],al
    inc bx
    loop s

    mov bx,10
    mov cx,3

s0:mov al,[bx]
or al,00100000B
mov [bx],al
inc bx
loop s0

mov ax,4c00h
int 21h

codesg ends
end start
```







## [bx+idata]

```
此种形式方便更灵活地定位内存地址，类似于高级语言中的数组
```



还可写成

```assembly
mov ax,[idata+bx]
mov ax,idata[bx]
mov ax,[bx].i
```





## [bx+si/di]



## [bx+si/di+idata]





## ⭐️️bx  si   di  bp

这四个寄存器可以在[...]形式中作为偏移地址来寻址，它们之间可以进行如下搭配

- bx+si/di
- bp+si/di

对于==bx+bp   si+di==都是错误的搭配



***值得说的是，在有bp的搭配中要使用ss作为段地址***





## 处理数据的两个基本问题

### ==数据在哪==

- ==cpu内部== 
  - 立即数       操作数包含在指令中—> ==mov ax,1==
  - 寄存器       操作数包含在寄存器中—>==mov ds,ax==
- ==内存==
  - 由==段地址：偏移地址==寻址得出
- ==端口==



#### 寻址方式（数据在内存中）

| 寻址方式                            | 名称             |
| ----------------------------------- | ---------------- |
| [idata]                             | 立即寻址         |
| [bx]  [si]  [di]  [bp]              | 寄存器间接寻址   |
| [bx/si/di/bp+idata]                 | 寄存器相对寻址   |
| [bx+si/di]    [bp+si/di]            | 基址变址寻址     |
| [bx+si/di+idata]   [bx+si/di+idata] | 相对基址变址寻址 |





![image-20210805172444706](C:\Users\翟\AppData\Roaming\Typora\typora-user-images\image-20210805172444706.png)





### ==数据的长度是多少==

- 由寄存器暗指
  - mov ax,1   ==字操作==
  - mov al,1   ==字节操作==



- 由 X ptr明指
  - mov word ptr [bx],1    ==字操作==  
  - mov byte ptr [bx],1     ==字节操作==



- 由指令暗指

  ***例如push指令，只能进行==字操作==***







### div指令

==除法指令==

***格式***

- div reg

- div （X ptr） 内存单元





- 除数：长度有==8==位和==16==位两种
- 被除数
  - 若除数为8位，被除数为==16==位，且存放在ax中
  - 若除数为16位，被除数为==32==位，高16位存放在==dx==中，低16位存放在==ax==中

- 结果
  - 若除数为8位，商存放在==al==中，余数存放在==ah==中
  - 若除数为16位，商存放在==ax==中，余数存放在==dx==中





### mul指令

==乘法指令==

- 乘数
  - 要么都是==8==位，一个默认放在==AL==中，另一个放在==8==位寄存器或内存==字节==单元中
  - 要么都是==16==位，一个默认放在==AX==中，另一个放在==16==位寄存器或内存==字==单元中

- 结果
  - 若是==8==位乘法，积默认放在==AX==中
  - 若是==16==位乘法，积==高位==默认放在==DX==中，==低位==默认存放在==AX==中



***格式***

```assembly
mul reg  ;mul cx
mul 内存单元 ;mul byte ptr 内存单元
            ;mul word ptr 内存单元
```











### 伪指令db dw dd dup

- db    定义字节型数据
- dw   定义字型数据
- dd   定义双字型数据



***dup***

==用于重复定义数据==

- 格式

  db/dw/dd   重复的次数   dup (对应类型的数据)







# 转移指令

==可以修改IP，或可以同时修改CS和IP的指令统称为转移指令==



- 转移行为
  - 修改IP                             jmp ax
  - 同时修改CS和IP             jmp 1000:0



- 段内转移

  - 段内短转移 

    范围：==-128～+127==  

  - 段内近转移

  ​      范围：==-32768～+32767==



- 段间转移





- 转移指令
  - 无条件转移
  - 条件转移
  - 循环指令
  - 过程
  - 中断





## 操作符offset

***格式***：==offset 标号==

***作用***：用于提取标号所在的偏移地址





## jmp



***jmp主要给出两种信息***

- 转移的目的地址
- 转移的距离
  - 段间转移
  - 段内短转移
  - 段内近转移





### 段内转移

#### 短转移

***格式***

```assembly
jmp short 标号
```



***例子***

```assembly
assume cs:codeseg
codeseg segment
   start: mov ax,1000h
          mov ds,ax
		  jmp short s
		  inc bx
		  add bx,ax
		  dec bx
	  s:  dec bx
codeseg ends
    end start
```



 观察其机器指令，发现其对应的机器指令==EB04==并不包含==目的地址==，那么cpu是如何完成转移的呢？

***原理***

cpu通过==转移位数==跳转到目的地址，那么又如何求出转移位数呢？



==转移位数的求法==：  标号处的地址—jmp指令后一条指令的地址



此例转移指令的执行过程：

- 从cs：ip指向的内存地址取出指令，放入指令缓冲器
- ip+(上一条指令的长度：2)
- 执行指令，ip向前(后)移动一定的位数：4，重复第一步











![image-20210806143814914](C:\Users\翟\AppData\Roaming\Typora\typora-user-images\image-20210806143814914.png)







#### 近转移

***格式***

```assembly
jmp near ptr 标号
```



***原理同短转移，区别在于移动的范围，short为8位，near ptr为16位***









### 段间转移（远转移）

***格式***

```assembly
jmp far ptr 标号
```



***功能***

前面提到的jmp指令仅仅只是对于ip的修改，机器指令中并未包含转移的目的地址

此格式的转移指令可以同时修改cs：ip







### 根据寄存器进行转移

***格式***

```assembly
jmp reg  ;16位
```



***功能***

通过寄存器修改ip的指向







### 根据内存单元地址进行转移

### 

#### 段内转移

***格式***

```assembly
jmp word ptr 内存单元地址
```





#### 段间转移

***格式***

```assembly
jmp dword ptr 内存单元地址
```



***高地址作为cs，低地址作为ip***





### 条件转移指令

#### jcxz

***格式***

```assembly
jcxz 标号
```



***原理***

与“jmp short 标号”的区别在于jcxz依据cx，jcxz的内层含义可用高级语言描述成：

```c
if(cx == 0)
    jcxz short 标号
```









#### loop

***格式***

```assembly
loop 标号
```



***原理***

与==jcxz==指令相同，一样是==短转移==指令，也同样依据cx

高级语言描述：

```c
while(cx--){
    jmp short b
}
```







### ret & retf & call



#### ret & retf

==ret==: 利用栈中的数据，修改ip，实现==近转移==

==retf==：利用栈中的数据，修改cs和ip，实现==远转移==



#### call

##### 根据位移

***格式***

```assembly
call 标号
```



***功能***

```assembly
相当于 

push IP
jmp near ptr 标号
```





##### 根据寄存器

***格式***

```assembly
call 16位reg
```



***功能***

```assembly
push IP
jmp 16位reg
```





##### 根据内存地址

- ***call word ptr 内存单元地址***

     ```assembly
     相当于
     push IP
     jmp word ptr 内存单元地址
     ```



- ***call dword ptr 内存单元地址***

```assembly
相当于
push CS
push IP
jmp far ptr 内存单元地址
```





#### call & ret retf配合使用

call可用来调用某个子程序，ret/retf可用来返回到断点（==call指令的后一条指令==）继续执行



***是不是很像高级语言中的函数调用***









